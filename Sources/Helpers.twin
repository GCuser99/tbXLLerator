'From: https://github.com/GCuser99/tbXLLerator
'Distrubuted under MIT License: https://github.com/GCuser99/tbXLLerator?tab=MIT-1-ov-file
'Copyright (c) 2026 GCUser99 (Michael Waite)

'------------------------------------------------------------------------------
' XLL MEMORY MANAGEMENT STRATEGY
'
' Excel XLL UDFs must return a pointer to an XLOPER12. This XLL uses dynamic allocation with xlbitDLLFree
'
'   [DllExport]
'   Public Function TBXLL_Example(...) As LongPtr
'       Dim xTemp As XLOPER12        ' local, per-call — no Static
'       ...
'       Return AllocResultToCaller(xTemp)
'   End Function
'
' Each call allocates its own independent XLOPER12 on the heap via
' AllocResultToCaller. Excel calls xlAutoFree12 when done with the result.
' This pattern allows Excel to execute the function concurrently across
' cells during multithreaded recalculation, which can dramatically improve
' performance on large models with many cells calling the same UDF.
'
' Register with ThreadSafe = True when UDF has no shared state
'
'
' ERROR HANDLING
' ------------------------------
' All code paths must set xTemp before returning. Use GoTo ReturnResult
' to funnel all paths through a single AllocResultToCaller call:
'
'   If Not Bind(...) Then GoTo ReturnResult  ' Bind sets xTemp on failure
'   If Excel12v(...) <> 0 Then
'       SetErrorResult xTemp                 ' must set explicitly on Excel12v failure
'       GoTo ReturnResult
'   End If
'   xTemp = GetXLNum12(result)
' ReturnResult:
'   Return AllocResultToCaller(xTemp)
'
' Note: Bind sets xTemp automatically on failure. Excel12v and GetXLMulti12
' do NOT — SetErrorResult xTemp must be called explicitly before GoTo.

' Why register input Args as U vs Q - three things:

' - No raw cell references with Q — btSingleCellRef is impossible. 
'   Functions like TBXLL_CellAddress and TBXLL_SheetName that need row/column coordinates or sheet identity cannot work with Q.
' - Can't pass references to Excel built-ins with Q — with U, you can pass pRange directly to xlfSum, xlfCountif, etc. and 
'   Excel operates on the original range efficiently. With Q, Excel has already expanded the range into an xltypeMulti array, 
'   so you're passing a potentially large array instead of a lightweight reference. For functions like TBXLL_SumArray that 
'   just delegate to a built-in, Q is actually slower.
' - Memory overhead for large ranges — with U, a reference to A1:A1000000 is a tiny xltypeSRef struct. 
'   With Q, Excel materializes the entire range into an xltypeMulti array before your function is even called. 
'   If your function only needs a subset or is just passing through to a built-in, that's wasted work and memory.

' So the rule would be: use Q for functions that need scalar inputs or that process every element of the array themselves. 
' Use U for functions that pass references to Excel built-ins, need cell coordinates, or where you want to defer/avoid materializing large ranges.

[Description("This Module contains convenient wrappers for the Jon Johnson's ExcelSDK")]
Module Helpers
    Option Explicit
    
    Public Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal Length As LongPtr)
    Public Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal uFlags As GMEM, ByVal dwBytes As LongPtr) As LongPtr
    Public Declare PtrSafe Function GlobalFree Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    
    Public DeclareWide PtrSafe Function MessageBox Lib "user32" Alias "MessageBoxW" (ByVal hWnd As LongPtr, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long
    'MessageBox 0, "xlAutoRemove called - unregistering UDFs", "XLL Diagnostic", 0
    
    Public Const addinLongName As String = "tbXLLerator Add-in v0.2"
    
    Public Enum GMEM
        GMEM_FIXED = &H0000
        GMEM_MOVEABLE = &H0002
        GMEM_NOCOMPACT = &H0010
        GMEM_NODISCARD = &H0020
        GMEM_ZEROINIT = &H0040
        GMEM_MODIFY = &H0080
        GMEM_DISCARDABLE = &H0100
        GMEM_NOT_BANKED = &H1000
        GMEM_SHARE = &H2000
        GMEM_DDESHARE = &H2000
        GMEM_NOTIFY = &H4000
        GMEM_LOWER = &H1000
        GMEM_VALID_FLAGS = &H7F72
        GMEM_INVALID_HANDLE = &H8000&
        GHND = GMEM_MOVEABLE Or GMEM_ZEROINIT
        GPTR = GMEM_FIXED Or GMEM_ZEROINIT
        GMEM_DISCARDED = &H4000
        GMEM_LOCKCOUNT = &H00FF
    End Enum
    
    '===========================================================
    ' Unified argument binding for XLOPER12-based UDFs
    '===========================================================
    
    '-----------------------------
    ' Target type enum
    '-----------------------------
    Public Enum BindType
        btNumber = 0
        btString = 1
        btBool = 2
        btDate = 3
        btArray = 4
        btSingleCellRef = 5
        btValue = 6
    End Enum
    
    '===========================================================
    ' Unified dispatcher: Bind
    '===========================================================
    ' Useful for when input arguments are registered as U (raw XLOPER12)
    Public Function Bind( _
        ByRef pIn As XLOPER12, _
        ByVal target As BindType, _
        ByRef outValue As Variant, _
        ByRef xResult As XLOPER12) As Boolean

        Dim d As Double
        Dim s As String
        Dim b As Boolean
        Dim dt As Double
        Dim arr() As Variant
        Dim r As XLREF12
        Dim v As Variant

        Select Case target
            Case btNumber
                If CoerceToNumber(pIn, d) Then
                    outValue = d
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btString
                If CoerceToString(pIn, s) Then
                    outValue = s
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btBool
                If CoerceToBool(pIn, b) Then
                    outValue = b
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btDate
                If CoerceToDate(pIn, dt) Then
                    outValue = dt
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btArray
                If CoerceToArray(pIn, arr) Then
                    outValue = arr
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btSingleCellRef
                ' Workaround: XLREF12 UDT cannot round-trip through Variant in twinBASIC.
                ' Here Row and column are returned as a 2-element Variant array: (rwFirst, colFirst).
                ' For full XLREF12 access, call ValidateSingleCellRef directly.
                If ValidateSingleCellRef(pIn, r) Then
                    Dim rc(1) As Variant
                    rc(0) = r.rwFirst + 1   ' Worksheet Row
                    rc(1) = r.colFirst + 1  ' Worksheet Column
                    outValue = rc
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case btValue
                ' Coerces any input (scalar, ref, or range) to a 1x1 multi-array
                ' and extracts element (0,0). For single cells and literals this
                ' returns the value directly; for multi-cell ranges it returns
                ' only the top-left cell value. Use btArray if you need all cells.
                Dim arrV() As Variant
                If CoerceToArray(pIn, arrV) Then
                    outValue = arrV(0, 0)
                    Bind = True
                Else
                    SetErrorResult xResult
                    Bind = False
                End If
            Case Else
                SetErrorResult xResult
                Bind = False
        End Select
    End Function
    
    ' Useful when registering input arguments as type Q (XLOPER12 coerced by Excel)
    Public Function BindQ( _
        ByRef pIn As XLOPER12, _
        ByVal target As BindType, _
        ByRef outValue As Variant, _
        ByRef xResult As XLOPER12) As Boolean

        Select Case target
            Case btNumber
                Select Case pIn.xltype
                    Case xltypeNum
                        outValue = Xloper12NumValue(pIn)
                        BindQ = True
                    Case xltypeInt
                        outValue = CDbl(Xloper12IntValue(pIn))
                        BindQ = True
                    Case xltypeBool
                        outValue = IIf(Xloper12BoolValue(pIn), 1#, 0#)
                        BindQ = True
                    Case xltypeMulti
                        ' Multi-cell range coerced to array — extract top-left
                        Dim numElem As XLOPER12
                        If ExtractFirstElement(pIn, numElem) Then
                            If numElem.xltype = xltypeNum Then
                                outValue = Xloper12NumValue(numElem)
                                BindQ = True
                            ElseIf numElem.xltype = xltypeInt Then
                                outValue = CDbl(Xloper12IntValue(numElem))
                                BindQ = True
                            Else
                                SetErrorResult xResult
                                BindQ = False
                            End If
                        Else
                            SetErrorResult xResult
                            BindQ = False
                        End If
                    Case Else
                        SetErrorResult xResult
                        BindQ = False
                End Select
            Case btString
                Select Case pIn.xltype
                    Case xltypeStr
                        outValue = Xloper12StrValue(pIn)
                        BindQ = True
                    Case xltypeNum
                        outValue = CStr(Xloper12NumValue(pIn))
                        BindQ = True
                    Case xltypeInt
                        outValue = CStr(Xloper12IntValue(pIn))
                        BindQ = True
                    Case xltypeBool
                        outValue = IIf(Xloper12BoolValue(pIn), "TRUE", "FALSE")
                        BindQ = True
                    Case xltypeMulti
                        Dim strElem As XLOPER12
                        If ExtractFirstElement(pIn, strElem) Then
                            If strElem.xltype = xltypeStr Then
                                outValue = Xloper12StrValue(strElem)
                                BindQ = True
                            ElseIf strElem.xltype = xltypeNum Then
                                outValue = CStr(Xloper12NumValue(strElem))
                                BindQ = True
                            Else
                                SetErrorResult xResult
                                BindQ = False
                            End If
                        Else
                            SetErrorResult xResult
                            BindQ = False
                        End If
                    Case Else
                        SetErrorResult xResult
                        BindQ = False
                End Select
            Case btBool
                Select Case pIn.xltype
                    Case xltypeBool
                        outValue = Xloper12BoolValue(pIn)
                        BindQ = True
                    Case xltypeNum
                        outValue = (Xloper12NumValue(pIn) <> 0#)
                        BindQ = True
                    Case xltypeInt
                        outValue = (Xloper12IntValue(pIn) <> 0)
                        BindQ = True
                    Case xltypeMulti
                        Dim boolElem As XLOPER12
                        If ExtractFirstElement(pIn, boolElem) Then
                            If boolElem.xltype = xltypeBool Then
                                outValue = Xloper12BoolValue(boolElem)
                                BindQ = True
                            ElseIf boolElem.xltype = xltypeNum Then
                                outValue = (Xloper12NumValue(boolElem) <> 0#)
                                BindQ = True
                            Else
                                SetErrorResult xResult
                                BindQ = False
                            End If
                        Else
                            SetErrorResult xResult
                            BindQ = False
                        End If
                    Case Else
                        SetErrorResult xResult
                        BindQ = False
                End Select
            Case btDate
                Dim dateResult As Boolean
                dateResult = BindQ(pIn, btNumber, outValue, xResult)
                If dateResult Then
                    If CDbl(outValue) < 0# Or CDbl(outValue) > 2958465# Then
                        SetErrorResult xResult
                        BindQ = False
                    Else
                        BindQ = True
                    End If
                Else
                    BindQ = False
                End If
            Case btArray
                ' Q already coerced ranges to xltypeMulti
                Select Case pIn.xltype
                    Case xltypeMulti
                        Dim arrV() As Variant
                        If CoerceToArray(pIn, arrV) Then
                            outValue = arrV
                            BindQ = True
                        Else
                            SetErrorResult xResult
                            BindQ = False
                        End If
                    Case xltypeNum, xltypeStr, xltypeBool, xltypeInt, xltypeErr
                        ' Scalar — wrap in 1x1 array
                        Dim scalar(0, 0) As Variant
                        Select Case pIn.xltype
                            Case xltypeNum:  scalar(0, 0) = Xloper12NumValue(pIn)
                            Case xltypeStr:  scalar(0, 0) = Xloper12StrValue(pIn)
                            Case xltypeBool: scalar(0, 0) = Xloper12BoolValue(pIn)
                            Case xltypeInt:  scalar(0, 0) = CDbl(Xloper12IntValue(pIn))
                            Case xltypeErr:  scalar(0, 0) = CVErr(Xloper12ErrValue(pIn))
                        End Select
                        outValue = scalar
                        BindQ = True
                    Case Else
                        SetErrorResult xResult
                        BindQ = False
                End Select
            Case btValue
                ' Extract scalar value directly
                Select Case pIn.xltype
                    Case xltypeNum
                        outValue = Xloper12NumValue(pIn)
                        BindQ = True
                    Case xltypeStr
                        outValue = Xloper12StrValue(pIn)
                        BindQ = True
                    Case xltypeBool
                        outValue = Xloper12BoolValue(pIn)
                        BindQ = True
                    Case xltypeInt
                        outValue = CDbl(Xloper12IntValue(pIn))
                        BindQ = True
                    Case xltypeErr
                        outValue = CVErr(Xloper12ErrValue(pIn))
                        BindQ = True
                    Case xltypeMulti
                        Dim valElem As XLOPER12
                        If ExtractFirstElement(pIn, valElem) Then
                            Select Case valElem.xltype
                                Case xltypeNum:  outValue = Xloper12NumValue(valElem)
                                Case xltypeStr:  outValue = Xloper12StrValue(valElem)
                                Case xltypeBool: outValue = Xloper12BoolValue(valElem)
                                Case xltypeInt:  outValue = CDbl(Xloper12IntValue(valElem))
                                Case xltypeErr:  outValue = CVErr(Xloper12ErrValue(valElem))
                                Case Else:       outValue = Empty
                            End Select
                            BindQ = True
                        Else
                            SetErrorResult xResult
                            BindQ = False
                        End If
                    Case xltypeNil, xltypeMissing
                        outValue = Empty
                        BindQ = True
                    Case Else
                        SetErrorResult xResult
                        BindQ = False
                End Select
            Case btSingleCellRef
                ' Q resolves all references — cannot extract cell coordinates
                SetErrorResult xResult
                BindQ = False
            Case Else
                SetErrorResult xResult
                BindQ = False
        End Select
    End Function

    ' Error helper function
    Public Sub SetErrorResult(ByRef xResult As XLOPER12)
        xResult.xltype = xltypeErr
        CopyMemory xResult.val(0), xlerrValue, LenB(xlerrValue)
    End Sub
    
    '--------------------------------------------------------------------------
    ' Extension to the API
    '--------------------------------------------------------------------------
    ' This functiion converts in input variant array to an XLOPER12 structure
    Public Function GetXLMulti12(ByRef arr() As Variant) As XLOPER12
        Dim rows As Long = UBound(arr, 1) + 1
        Dim cols As Long = UBound(arr, 2) + 1
        Dim count As Long = rows * cols
    
        ' Allocate memory for the element array
        Dim elem As XLOPER12
        Dim elemSize As Long = LenB(elem)
        Dim lpArray As LongPtr = GlobalAlloc(GPTR, count * elemSize)
    
        If lpArray = 0 Then Exit Function
    
        Dim r As Long, c As Long, i As Long
        For r = 0 To rows - 1
            For c = 0 To cols - 1
                i = r * cols + c
                Dim xElem As XLOPER12
                xElem = GetXLVariant12(arr(r, c))
                CopyMemory ByVal lpArray + (i * elemSize), xElem, elemSize
            Next c
        Next r
        
        ' Build the xltypeMulti XLOPER12
        Dim pVal As LongPtr
        GetXLMulti12.xltype = xltypeMulti
        pVal = VarPtr(GetXLMulti12.val(0))
        CopyMemory ByVal pVal, lpArray, LenB(Of LongPtr)
        CopyMemory ByVal pVal + LenB(Of LongPtr), rows, 4
        CopyMemory ByVal pVal + LenB(Of LongPtr) + 4, cols, 4
    End Function
    
    Public Function GetXLVariant12(ByVal v As Variant) As XLOPER12
        Select Case VarType(v)
            Case vbDouble
                GetXLVariant12 = GetXLNum12(CDbl(v))
            Case vbLong, vbInteger
                GetXLVariant12 = GetXLInt12(CLng(v))
            Case vbBoolean
                GetXLVariant12 = GetXLBool12(CBool(v))
            Case vbString
                GetXLVariant12 = GetXLString12(CStr(v))
            Case vbError
                GetXLVariant12 = GetXLErr12(CLng(v))
            Case Else
                GetXLVariant12.xltype = xltypeNil
        End Select
    End Function
    
    Public Sub FreeXLMulti12(ByRef xMulti As XLOPER12)
        If xMulti.xltype <> xltypeMulti Then Exit Sub
        Dim pVal As LongPtr
        Dim lpArray As LongPtr
        pVal = VarPtr(xMulti.val(0))
        CopyMemory lpArray, ByVal pVal, LenB(Of LongPtr)
        GlobalFree lpArray
        xMulti.xltype = xltypeNil
    End Sub
    
    ' Allocates a heap XLOPER12 with xlbitDLLFree set for thread-safe UDF return.
    ' Excel calls xlAutoFree12 to free the allocation when done with the result.
    ' Caller must NOT free - ownership transfers to Excel.
    Public Function AllocResultToCaller(ByRef x As XLOPER12) As LongPtr
        Dim pResult As LongPtr
        pResult = GlobalAlloc(GPTR, LenB(Of XLOPER12))
        If pResult = 0 Then Return 0
        x.xltype = x.xltype Or xlbitDLLFree
        CopyMemory ByVal pResult, x, LenB(Of XLOPER12)
        Return pResult
    End Function

    '===========================================================
    ' Core coercion helpers (XLOPER12 -> typed)
    '===========================================================

    Public Function CoerceToBool( _
        ByRef pIn As XLOPER12, _
        ByRef outBool As Boolean) As Boolean

        Dim xlt(0) As XLOPER12
        Dim xle(1) As XLOPER12
        Dim rc As Long

        Select Case pIn.xltype
            Case xltypeBool
                outBool = Xloper12BoolValue(pIn)
                CoerceToBool = True
                Exit Function
            Case xltypeNum
                outBool = (Xloper12NumValue(pIn) <> 0)
                CoerceToBool = True
                Exit Function
            Case xltypeInt
                outBool = (Xloper12IntValue(pIn) <> 0)
                CoerceToBool = True
                Exit Function
            Case xltypeStr, xltypeSRef, xltypeRef, xltypeMulti
                xle(0) = pIn
                xle(1) = GetXLInt12(xltypeNum)

                rc = Excel12v(xlCoerce, xlt(0), 2, xle)
                If rc = 0 Then
                    outBool = (Xloper12NumValue(xlt(0)) <> 0)
                    Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                    CoerceToBool = True
                    Exit Function
                End If

                Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                CoerceToBool = False
                Exit Function
            Case Else
                CoerceToBool = False
                Exit Function
        End Select
    End Function

    Public Function CoerceToNumber( _
        ByRef pIn As XLOPER12, _
        ByRef outNum As Double) As Boolean

        Dim xlt(0) As XLOPER12
        Dim xle(1) As XLOPER12
        Dim rc As Long

        Select Case pIn.xltype
            Case xltypeNum
                outNum = Xloper12NumValue(pIn)
                CoerceToNumber = True
                Exit Function
            Case xltypeInt
                outNum = Xloper12IntValue(pIn)
                CoerceToNumber = True
                Exit Function
            Case xltypeBool
                outNum = IIf(Xloper12BoolValue(pIn), 1#, 0#)
                CoerceToNumber = True
                Exit Function
            Case xltypeStr, xltypeSRef, xltypeRef, xltypeMulti
                xle(0) = pIn
                xle(1) = GetXLInt12(xltypeNum)

                rc = Excel12v(xlCoerce, xlt(0), 2, xle)
                If rc = 0 Then
                    outNum = Xloper12NumValue(xlt(0))
                    Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                    CoerceToNumber = True
                    Exit Function
                End If

                Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                CoerceToNumber = False
                Exit Function
            Case Else
                CoerceToNumber = False
                Exit Function
        End Select
    End Function

    Public Function CoerceToString( _
        ByRef pIn As XLOPER12, _
        ByRef outStr As String) As Boolean

        Dim xlt(0) As XLOPER12
        Dim xle(1) As XLOPER12
        Dim rc As Long

        Select Case pIn.xltype
            Case xltypeStr
                outStr = Xloper12StrValue(pIn)
                CoerceToString = True
                Exit Function
            Case xltypeNum
                outStr = CStr(Xloper12NumValue(pIn))
                CoerceToString = True
                Exit Function
            Case xltypeInt
                outStr = CStr(Xloper12IntValue(pIn))
                CoerceToString = True
                Exit Function
            Case xltypeBool
                outStr = IIf(Xloper12BoolValue(pIn), "TRUE", "FALSE")
                CoerceToString = True
                Exit Function
            Case xltypeSRef, xltypeRef, xltypeMulti
                xle(0) = pIn
                xle(1) = GetXLInt12(xltypeStr)

                rc = Excel12v(xlCoerce, xlt(0), 2, xle)
                If rc = 0 Then
                    outStr = Xloper12StrValue(xlt(0))
                    Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                    CoerceToString = True
                    Exit Function
                End If

                Excel12v xlFree, ByVal vbNullPtr, 1, xlt
                CoerceToString = False
                Exit Function
            Case Else
                CoerceToString = False
                Exit Function
        End Select
    End Function

    Public Function ValidateSingleCellRef( _
        ByRef pIn As XLOPER12, _
        ByRef outRef As XLREF12) As Boolean

        Dim xlt(0) As XLOPER12
        Dim xle(1) As XLOPER12
        Dim rc As Long
        Dim sref As XLREF12

        Select Case pIn.xltype
            Case xltypeSRef
                ' xltypeSRef val union layout:
                ' offset 0: 4 bytes (WORD count always=1, plus 2 bytes padding)
                ' offset 4: XLREF12 (rwFirst, rwLast, colFirst, colLast)
                CopyMemory sref, ByVal VarPtr(pIn.val(0)) + 4, LenB(sref)
                If sref.rwFirst = sref.rwLast And _
                   sref.colFirst = sref.colLast Then
                    outRef = sref
                    ValidateSingleCellRef = True
                    Exit Function
                End If
                ValidateSingleCellRef = False
            Case xltypeRef
                ' xltypeRef val layout (64-bit):
                ' offset 0: LongPtr — pointer to XLMREF12
                ' offset 8: Long — idSheet
                Dim lpMref As LongPtr
                CopyMemory lpMref, ByVal VarPtr(pIn.val(0)), LenB(Of LongPtr)
    
                If lpMref = 0 Then
                    ValidateSingleCellRef = False
                    Exit Function
                End If
    
                ' Read count from XLMREF12
                Dim refCount As Integer
                CopyMemory refCount, ByVal lpMref, 2
    
                ' Must be exactly one rectangular region
                If refCount <> 1 Then
                    ValidateSingleCellRef = False
                    Exit Function
                End If
    
                ' Read the first XLREF12 (after the 2-byte count + padding)
                ' XLMREF12 layout: 2 bytes count, then padding to align XLREF12
                CopyMemory sref, ByVal lpMref + 4, LenB(sref)
    
                If sref.rwFirst = sref.rwLast And _
                   sref.colFirst = sref.colLast Then
                    outRef = sref
                    ValidateSingleCellRef = True
                Else
                    ValidateSingleCellRef = False
                End If
            Case xltypeStr
                ValidateSingleCellRef = False
            Case Else
                ValidateSingleCellRef = False
        End Select
    End Function

    Public Function CoerceToDate( _
        ByRef pIn As XLOPER12, _
        ByRef outDate As Double) As Boolean

        Dim num As Double

        If Not CoerceToNumber(pIn, num) Then
            CoerceToDate = False
            Exit Function
        End If

        ' Optional: Excel date range sanity check (max = December 31, 9999)
        If num < 0# Or num > 2958465# Then
            CoerceToDate = False
            Exit Function
        End If

        outDate = num
        CoerceToDate = True
    End Function
    
    Public Function CoerceToArray( _
        ByRef pIn As XLOPER12, _
        ByRef outArr() As Variant) As Boolean

        Dim xArgs(1) As XLOPER12
        Dim xMulti(0) As XLOPER12
        Dim xFree(0) As XLOPER12
        Dim outRows As Long, outCols As Long

        xArgs(0) = pIn
        xArgs(1) = GetXLInt12(xltypeMulti)

        If Excel12v(xlCoerce, xMulti(0), 2, xArgs) <> 0 Then
            CoerceToArray = False
            Exit Function
        End If

        Dim pVal As LongPtr
        Dim lpArray As LongPtr
        
        pVal = VarPtr(xMulti(0).val(0))
        CopyMemory lpArray, ByVal pVal, LenB(Of LongPtr)
        CopyMemory outRows, ByVal pVal + LenB(Of LongPtr), 4
        CopyMemory outCols, ByVal pVal + LenB(Of LongPtr) + 4, 4

        ReDim outArr(0 To outRows - 1, 0 To outCols - 1)

        Dim elem As XLOPER12
        Dim elemSize As Long = LenB(elem)
        Dim r As Long, c As Long, i As Long

        For r = 0 To outRows - 1
            For c = 0 To outCols - 1
                i = r * outCols + c
                CopyMemory elem, ByVal lpArray + (i * elemSize), elemSize
                Select Case elem.xltype
                    Case xltypeNum
                        outArr(r, c) = Xloper12NumValue(elem)
                    Case xltypeInt
                        outArr(r, c) = Xloper12IntValue(elem)
                    Case xltypeBool
                        outArr(r, c) = Xloper12BoolValue(elem)
                    Case xltypeStr
                        outArr(r, c) = Xloper12StrValue(elem)
                    Case xltypeErr
                        ' Preserve typed error — callers can check VarType(v) = vbError
                        outArr(r, c) = CVErr(Xloper12ErrValue(elem))
                    Case xltypeNil, xltypeBlank
                        ' Empty cells coerced in multi-array are typically xltypeNil but xltypeBlank can appear in some edge cases
                        outArr(r, c) = Empty
                    Case Else
                        outArr(r, c) = Empty
                End Select
            Next c
        Next r

        xFree(0) = xMulti(0)
        Excel12v xlFree, ByVal vbNullPtr, 1, xFree

        CoerceToArray = True
    End Function
    
    Public Function XlErrToString(ByVal errCode As Long) As String
        Select Case errCode
            Case xlerrNull:         XlErrToString = "#NULL!"
            Case xlerrDiv0:         XlErrToString = "#DIV/0!"
            Case xlerrValue:        XlErrToString = "#VALUE!"
            Case xlerrRef:          XlErrToString = "#REF!"
            Case xlerrName:         XlErrToString = "#NAME?"
            Case xlerrNum:          XlErrToString = "#NUM!"
            Case xlerrNA:           XlErrToString = "#N/A"
            Case xlerrGettingData:  XlErrToString = "#GETTING_DATA"
            Case Else:              XlErrToString = "#UNKNOWN!"
        End Select
    End Function
    
    Private Function ExtractFirstElement( _
        ByRef pIn As XLOPER12, _
        ByRef outElem As XLOPER12) As Boolean

        Dim lpArray As LongPtr
        CopyMemory lpArray, ByVal VarPtr(pIn.val(0)), LenB(Of LongPtr)

        If lpArray = 0 Then
            ExtractFirstElement = False
            Exit Function
        End If

        CopyMemory outElem, ByVal lpArray, LenB(outElem)
        ExtractFirstElement = True
    End Function
       
End Module