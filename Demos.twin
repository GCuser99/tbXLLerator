Module Demos
    
    '------------------------------------------------------------------------------
    ' MEMORY MANAGEMENT STRATEGY: Static vs Dynamic (xlbitDLLFree)
    '
    ' This XLL uses two memory management patterns:
    '
    ' PATTERN 1: Static result (single-threaded UDFs)
    ' ------------------------------------------------
    '   [DllExport]
    '   Public Function TBXLL_Example(...) As LongPtr
    '       Static xResult As XLOPER12   ' persists for XLL lifetime
    '       ...
    '       Return VarPtr(xResult)       ' Excel reads before next call
    '   End Function
    '
    ' Safe and correct for single-threaded recalculation because Excel reads
    ' the result synchronously before the function can be called again.
    ' Register with ThreadSafe = False (default).
    '
    ' PATTERN 2: Dynamic allocation with xlbitDLLFree (thread-safe UDFs)
    ' ------------------------------------------------------------------
    '   [DllExport]
    '   Public Function TBXLL_Example(...) As LongPtr
    '       Dim xTemp As XLOPER12        ' local, per-call
    '       ...
    '       Dim pResult As LongPtr = GlobalAlloc(GPTR, LenB(Of XLOPER12))
    '       xTemp.xltype = xTemp.xltype Or xlbitDLLFree
    '       CopyMemory ByVal pResult, xTemp, LenB(Of XLOPER12)
    '       Return pResult               ' Excel calls xlAutoFree12 when done
    '   End Function
    '
    ' Each call allocates its own independent XLOPER12 on the heap, making
    ' it safe for concurrent execution. Register with ThreadSafe = True.
    '
    ' xlAutoFree12 IMPLEMENTATION NOTE:
    ' ----------------------------------
    ' The standard XLL SDK declares xlAutoFree12 as:
    '   void WINAPI xlAutoFree12(LPXLOPER12 pResult)
    '
    ' In C, LPXLOPER12 is the raw pointer value so GlobalFree(pResult) works
    ' correctly. In twinBASIC, ByRef XLOPER12 does not expose the raw pointer
    ' value in the same way -- VarPtr(pResult) returns the stack address of
    ' the ByRef parameter, not the original GlobalAlloc pointer.
    '
    ' For this reason xlAutoFree12 is declared as ByVal LongPtr instead:
    '   Public Sub xlAutoFree12(ByVal pResult As LongPtr)
    '
    ' This receives the exact pointer value returned by the UDF, which is
    ' the original GlobalAlloc pointer that must be passed to GlobalFree.
    ' This is a twinBASIC-specific adaptation -- the behavior is identical
    ' to the standard C implementation from Excel's perspective.
    '
    ' CHOOSING BETWEEN PATTERNS:
    ' --------------------------
    ' Use Static (Pattern 1) when:
    '   - UDF maintains state across calls (e.g. TBXLL_RecalcCounter)
    '   - UDF calls non-thread-safe Excel API functions (e.g. xlSheetNm)
    '   - UDF is volatile (Excel does not call volatile functions concurrently)
    '
    ' Use Dynamic/xlbitDLLFree (Pattern 2) when:
    '   - UDF is a pure function with no shared state
    '   - UDF makes no Excel API calls
    '   - UDF is called across many cells in large models (performance benefit)
    '------------------------------------------------------------------------------

    'Another version from ChatGPT
    '------------------------------------------------------------------------------
    ' XLL MEMORY MANAGEMENT STRATEGY
    '
    ' Excel XLL UDFs must return a pointer to an XLOPER12. How that memory is
    ' managed depends on whether the function is registered as thread-safe.
    '
    ' This XLL uses two distinct, mutually exclusive patterns:
    '
    '
    ' PATTERN 1: STATIC RESULT (Non-thread-safe UDFs)
    ' ----------------------------------------------
    '   [DllExport]
    '   Public Function TBXLL_Example(...) As LongPtr
    '       Static xResult As XLOPER12   ' persists for XLL lifetime
    '       ...
    '       Return VarPtr(xResult)
    '   End Function
    '
    ' Excel guarantees that non-thread-safe UDFs are never executed concurrently.
    ' Therefore, returning a pointer to static storage is safe: Excel reads the
    ' result synchronously before the function can be entered again.
    '
    ' Use this pattern when:
    '   - The UDF maintains shared or persistent state
    '   - The UDF calls non-thread-safe Excel APIs (e.g. xlSheetNm, xlCaller)
    '   - The UDF is volatile or otherwise serialized by Excel
    '
    ' Register with ThreadSafe = False (default).
    '
    '
    ' PATTERN 2: DYNAMIC ALLOCATION WITH xlbitDLLFree (Thread-safe UDFs)
    ' -----------------------------------------------------------------
    '   [DllExport]
    '   Public Function TBXLL_Example(...) As LongPtr
    '       Dim xTemp As XLOPER12
    '       ...
    '       Dim pResult As LongPtr = GlobalAlloc(GPTR, LenB(Of XLOPER12))
    '       xTemp.xltype = xTemp.xltype Or xlbitDLLFree
    '       CopyMemory ByVal pResult, xTemp, LenB(Of XLOPER12)
    '       Return pResult
    '   End Function
    '
    ' Each call allocates its own independent XLOPER12 on the heap. The returned
    ' XLOPER12 must have xlbitDLLFree set so Excel knows to call xlAutoFree12
    ' when it is finished with the result.
    '
    ' This pattern is required for thread-safe UDFs, which Excel may execute
    ' concurrently on multiple threads.
    '
    ' Register with ThreadSafe = True.
    '
    '
    ' xlAutoFree12 IMPLEMENTATION NOTE (twinBASIC)
    ' -------------------------------------------
    ' The Excel SDK declares:
    '   void WINAPI xlAutoFree12(LPXLOPER12 pResult)
    '
    ' In C, LPXLOPER12 is the raw pointer value returned by the UDF. In twinBASIC,
    ' declaring xlAutoFree12 as ByRef XLOPER12 does NOT expose that raw pointer;
    ' VarPtr(pResult) would refer to the stack address of the ByRef parameter.
    '
    ' Therefore, xlAutoFree12 must be declared as:
    '
    '   Public Sub xlAutoFree12(ByVal pResult As LongPtr)
    '
    ' This receives the exact pointer value returned by the UDF, which must be
    ' passed to GlobalFree. From Excel's perspective, this is ABI-equivalent to
    ' the standard C implementation.
    '
    '
    ' IMPORTANT WARNING: DO NOT MIX PATTERNS
    ' -------------------------------------
    ' A UDF must use exactly ONE of these patterns.
    '
    ' - Do NOT return static storage from a thread-safe UDF.
    ' - Do NOT allocate dynamically without setting xlbitDLLFree.
    ' - Do NOT reuse static XLOPER12 storage across concurrent calls.
    '
    ' Mixing patterns leads to data races, memory corruption, or Excel crashes.
    '
    '
    ' THREAD-SAFE REGISTRATION EXAMPLE
    ' -------------------------------
    ' Example type text for a thread-safe worksheet function returning a number:
    '
    '   TypeText = "1D"    ' Worksheet function, returns Double
    '   ThreadSafe = True
    '
    '------------------------------------------------------------------------------
       
    
    
    
    ' Demonstrates: btNumber binding for two scalar arguments, direct numeric return
    ' Example: =TBXLL_Multiply(3, 4) -> 12
    [DllExport]
    Public Function TBXLL_Multiply( _
        ByRef pA As XLOPER12, _
        ByRef pB As XLOPER12) As LongPtr

        ' Static required: Excel expects a stable XLOPER12 pointer that outlives the function call
        Static xResult As XLOPER12
        Dim a As Double, b As Double

        If Not Bind(pA, btNumber, a, xResult) Then Return VarPtr(xResult)
        If Not Bind(pB, btNumber, b, xResult) Then Return VarPtr(xResult)

        xResult = GetXLNum12(a * b)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Mixed-type binding (btNumber, btBool, btString) in a single UDF
    ' Example: =TBXLL_ConditionalAdd(5, TRUE, "Total") -> "Total: 15"
    [DllExport]
    Public Function TBXLL_ConditionalAdd( _
        ByRef pNum As XLOPER12, _
        ByRef pFlag As XLOPER12, _
        ByRef pLabel As XLOPER12) As LongPtr
        
        ' Static required: Excel expects a stable XLOPER12 pointer that outlives the function call
        Static xResult As XLOPER12
        Dim n As Double
        Dim flag As Boolean
        Dim label As String

        If Not Bind(pNum, btNumber, n, xResult) Then Return VarPtr(xResult)
        If Not Bind(pFlag, btBool, flag, xResult) Then Return VarPtr(xResult)
        If Not Bind(pLabel, btString, label, xResult) Then Return VarPtr(xResult)

        If flag Then
            xResult = GetXLString12(label & ": " & CStr(n + 10))
        Else
            xResult = GetXLString12(label & ": " & CStr(n))
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Optional argument handling using xltypeMissing detection
    ' Example: =TBXLL_AddOptional(1, 2) -> 3  |  =TBXLL_AddOptional(1, 2, 3) -> 6
    [DllExport]
    Public Function TBXLL_AddOptional( _
        ByRef pA As XLOPER12, _
        ByRef pB As XLOPER12, _
        ByRef pC As XLOPER12) As LongPtr
        
        ' Static required: Excel expects a stable XLOPER12 pointer that outlives the function call
        Static xResult As XLOPER12
        Dim a As Double, b As Double, c As Double

        If Not Bind(pA, btNumber, a, xResult) Then Return VarPtr(xResult)
        If Not Bind(pB, btNumber, b, xResult) Then Return VarPtr(xResult)

        ' Optional argument: default = 0
        If pC.xltype = xltypeMissing Then
            c = 0
        ElseIf Not Bind(pC, btNumber, c, xResult) Then
            Return VarPtr(xResult)
        End If

        xResult = GetXLNum12(a + b + c)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Direct pass-through of a range argument to an Excel built-in
    ' Example: =TBXLL_SumArray(A1:A3) -> SUM(A1:A3)
    [DllExport]
    Public Function TBXLL_SumArray(ByRef pArr As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim args(0) As XLOPER12

        args(0) = pArr

        ' Call Excel's SUM function directly
        If Excel12v(xlfSum, xResult, 1, args) <> 0 Then
            SetErrorResult xResult
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Single-argument pass-through to an Excel text built-in
    ' Example: =TBXLL_Upper("abc") -> "ABC"
    [DllExport]
    Public Function TBXLL_Upper(ByRef pText As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim args(0) As XLOPER12

        args(0) = pText

        If Excel12v(xlfUpper, xResult, 1, args) <> 0 Then
            SetErrorResult xResult
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Returning an xltypeMulti array result from an Excel built-in (Ctrl-Shift-Enter)
    ' Example: =TBXLL_Transpose(A1:C2) -> transposed array
    [DllExport]
    Public Function TBXLL_Transpose(ByRef pArr As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim args(0) As XLOPER12

        args(0) = pArr

        If Excel12v(xlfTranspose, xResult, 1, args) <> 0 Then
            SetErrorResult xResult
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Multi-argument pass-through to an Excel built-in
    ' Example: =TBXLL_CountIf(A1:A10, ">5") -> COUNTIF(A1:A10, ">5")
    [DllExport]
    Public Function TBXLL_CountIf( _
        ByRef pRange As XLOPER12, _
        ByRef pCriteria As XLOPER12) As LongPtr

        Static xResult As XLOPER12
        Dim args(1) As XLOPER12

        args(0) = pRange
        args(1) = pCriteria

        If Excel12v(xlfCountif, xResult, 2, args) <> 0 Then
            SetErrorResult xResult
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Chaining multiple Excel built-in calls with intermediate xlFree cleanup
    ' Example: =TBXLL_Average(A1:A4) -> AVERAGE(A1:A4)
    [DllExport]
    Public Function TBXLL_Average(ByRef pArr As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim sumRes As XLOPER12
        Dim cntRes As XLOPER12
        Dim args(0) As XLOPER12
        Dim freeArgs(0) As XLOPER12

        args(0) = pArr

        If Excel12v(xlfSum, sumRes, 1, args) <> 0 Then GoTo Fail
        If Excel12v(xlfCount, cntRes, 1, args) <> 0 Then
            freeArgs(0) = sumRes
            Excel12v xlFree, ByVal vbNullPtr, 1, freeArgs
            GoTo Fail
        End If

        xResult = GetXLNum12(Xloper12NumValue(sumRes) / Xloper12NumValue(cntRes))

        ' Free Excel-allocated results (must use array)
        freeArgs(0) = sumRes
        Excel12v xlFree, ByVal vbNullPtr, 1, freeArgs

        freeArgs(0) = cntRes
        Excel12v xlFree, ByVal vbNullPtr, 1, freeArgs

        Return VarPtr(xResult)

    Fail:
        SetErrorResult xResult
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Zero-argument Excel built-in call; volatility via registration (udf.Visibility) not function code
    ' Example: =TBXLL_Now() -> current date/time
    [DllExport]
    Public Function TBXLL_Now() As LongPtr
        Static xResult As XLOPER12

        If Excel12v(xlfNow, xResult, 0) <> 0 Then
            SetErrorResult xResult
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Returning a specific Excel error code via GetXLErr12
    ' Example: =TBXLL_AlwaysDiv0() -> #DIV/0!
    [DllExport]
    Public Function TBXLL_AlwaysDiv0() As LongPtr
        Static xResult As XLOPER12
        xResult = GetXLErr12(xlerrDiv0)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Domain validation with conditional GetXLErr12 vs GetXLNum12 return
    ' Example: =TBXLL_SqrtChecked(-1) -> #NUM!  |  =TBXLL_SqrtChecked(4) -> 2
    [DllExport]
    Public Function TBXLL_SqrtChecked(ByRef pNum As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim n As Double

        If Not Bind(pNum, btNumber, n, xResult) Then Return VarPtr(xResult)

        If n < 0 Then
            xResult = GetXLErr12(xlerrNum)
        Else
            xResult = GetXLNum12(Sqr(n))
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Two btNumber bindings with explicit divide-by-zero error path
    ' Example: =TBXLL_Divide(10, 2) -> 5  |  =TBXLL_Divide(10, 0) -> #DIV/0!
    [DllExport]
    Public Function TBXLL_Divide( _
        ByRef pA As XLOPER12, _
        ByRef pB As XLOPER12) As LongPtr

        Static xResult As XLOPER12
        Dim a As Double, b As Double

        If Not Bind(pA, btNumber, a, xResult) Then Return VarPtr(xResult)
        If Not Bind(pB, btNumber, b, xResult) Then Return VarPtr(xResult)

        If b = 0 Then
            xResult = GetXLErr12(xlerrDiv0)
        Else
            xResult = GetXLNum12(a / b)
        End If

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Returning xlerrNA for not-found semantics
    ' Example: =TBXLL_NotFound() -> #N/A
    [DllExport]
    Public Function TBXLL_NotFound() As LongPtr
        Static xResult As XLOPER12

        xResult = GetXLErr12(xlerrNA)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Direct xltype inspection to enforce strict input type before binding
    ' Example: =TBXLL_TextOnly("hi") -> "OK: hi"  |  =TBXLL_TextOnly(42) -> #VALUE!
    [DllExport]
    Public Function TBXLL_TextOnly(ByRef pText As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim s As String

        ' Strict type enforcement: reject anything that is not a string
        If (pText.xltype And xltypeStr) = 0 Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        ' Now safely bind as string (Bind will succeed)
        If Not Bind(pText, btString, s, xResult) Then
            Return VarPtr(xResult)
        End If

        xResult = GetXLString12("OK: " & s)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: xlFree on a successfully obtained result that is deliberately discarded
    ' Example: =TBXLL_FailAfterSum(A1:A3) -> #VALUE!
    [DllExport]
    Public Function TBXLL_FailAfterSum(ByRef pArr As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim temp As XLOPER12
        Dim args(0) As XLOPER12
        Dim freeArgs(0) As XLOPER12

        args(0) = pArr

        If Excel12v(xlfSum, temp, 1, args) <> 0 Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        ' Discard result and return error intentionally
        freeArgs(0) = temp
        Excel12v xlFree, ByVal vbNullPtr, 1, freeArgs

        xResult = GetXLErr12(xlerrValue)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Static variable persistence across recalculations with volatile registration (udf.Visibility) not function code
    ' Example: =TBXLL_RecalcCounter() -> increments on each recalc
    [DllExport]
    Public Function TBXLL_RecalcCounter() As LongPtr
        Static xResult As XLOPER12
        Static counter As Long

        counter = counter + 1
        xResult = GetXLInt12(counter)

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: GetXLString12 return mirroring the xlAddInManagerInfo12 registration string
    ' Example: =TBXLL_AddInInfo() -> "tB XLL Add-in v2.0"
    [DllExport]
    Public Function TBXLL_AddInInfo() As LongPtr
        Static xResult As XLOPER12
        ' Match the string returned by xlAddInManagerInfo12
        xResult = GetXLString12("tB XLL Add-in v2.0")
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Optional btBool argument, xlfTranspose built-in preprocessing, btArray conversion with xlFree
    ' Example: =TBXLL_Join({1,2;3,4}, FALSE) -> "1,2,3,4"  |  =TBXLL_Join({1,2;3,4}, TRUE) -> "1,3,2,4"
    [DllExport]
    Public Function TBXLL_Join(ByRef pRange As XLOPER12, ByRef pTranspose As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim arrV() As Variant
        Dim transpose As Boolean

        ' Optional argument: default = False
        If pTranspose.xltype = xltypeMissing Then
            transpose = False
        ElseIf Not Bind(pTranspose, btBool, transpose, xResult) Then
            Return VarPtr(xResult)
        End If
        
        If transpose Then
            ' Use Excel's internal Transpose function
            ' This is not needed of course - could do same in array emumeration below 
            ' but just to show how to use built-ins along with array enumeration
            Dim args(0) As XLOPER12
            args(0) = pRange

            If Excel12v(xlfTranspose, xResult, 1, args) <> 0 Then
                SetErrorResult xResult
                Return VarPtr(xResult)
            End If
            pRange = xResult
        End If
        
        ' Convert to a variant array and process
        If Not Bind(pRange, btArray, arrV, xResult) Then Return VarPtr(xResult)
        
        Dim total As Double
        Dim r As Long, c As Long
        Dim txt As String

        For r = 0 To UBound(arrV, 1)
            For c = 0 To UBound(arrV, 2)
                Select Case VarType(arrV(r, c))
                    Case vbDouble, vbLong, vbDate, vbError
                        txt = txt & CStr(arrV(r, c)) & ","
                    Case vbString, vbEmpty
                        txt = txt & arrV(r, c) & ","
                End Select
            Next c
        Next r
        
        If Len(txt) > 1 Then txt = Left$(txt, Len(txt) - 1)
        
        xResult = GetXLString12(txt)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: xlSheetNm callback to extract sheet name from a cell reference argument
    ' Example: =TBXLL_SheetName(A1) -> "[Book1.xlsx]Sheet1"
    [DllExport]
    Public Function TBXLL_SheetName(ByRef pRef As XLOPER12) As LongPtr
        Static xResult As XLOPER12

        ' pRef must be a cell reference so we can extract the sheet context
        Dim xArgs(0) As XLOPER12
        Dim xOut(0) As XLOPER12
        Dim xFree(0) As XLOPER12

        xArgs(0) = pRef
        If Excel12v(xlSheetNm, xOut(0), 1, xArgs) <> 0 Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        xResult = GetXLString12(Xloper12StrValue(xOut(0)))

        xFree(0) = xOut(0)
        Excel12v xlFree, ByVal vbNullPtr, 1, xFree

        Return VarPtr(xResult)
    End Function

    ' Demonstrates: btValue binding returning Empty variant for blank cells, IsEmpty detection
    ' Example: =TBXLL_IsEmptyCell(A1) -> TRUE if A1 is blank, FALSE otherwise
    [DllExport]
    Public Function TBXLL_IsEmptyCell(ByRef cell As XLOPER12) As LongPtr
        Static xRes As XLOPER12
        Dim v As Variant

        If Not Bind(cell, btValue, v, xRes) Then Return VarPtr(xRes)

        xRes = GetXLBool12(IsEmpty(v))
        Return VarPtr(xRes)
    End Function

    ' Demonstrates: btArray binding for two ranges, dimension validation, GetXLMulti12 array return with FreeXLMulti12
    ' Example: =TBXLL_MultiplyArrays({1,2,3;4,5,6}, {2,2,2;3,3,3}) -> {2,4,6;12,15,18}  [Ctrl-Shift-Enter]
    [DllExport]
    Public Function TBXLL_MultiplyArrays( _
        ByRef pArr1 As XLOPER12, _
        ByRef pArr2 As XLOPER12) As LongPtr

        Static xResult As XLOPER12
        Dim arr1() As Variant
        Dim arr2() As Variant
        Dim v As Variant

        ' Bind both input arrays
        If Not Bind(pArr1, btArray, arr1, xResult) Then Return VarPtr(xResult)
        If Not Bind(pArr2, btArray, arr2, xResult) Then Return VarPtr(xResult)

        ' Validate dimensions match
        If UBound(arr1, 1) <> UBound(arr2, 1) Or _
           UBound(arr1, 2) <> UBound(arr2, 2) Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        ' Build result variant array
        Dim rows As Long = UBound(arr1, 1) + 1
        Dim cols As Long = UBound(arr1, 2) + 1
        Dim arrOut() As Variant
        ReDim arrOut(rows - 1, cols - 1)

        Dim r As Long, c As Long
        For r = 0 To rows - 1
            For c = 0 To cols - 1
                If VarType(arr1(r, c)) = vbDouble And _
                   VarType(arr2(r, c)) = vbDouble Then
                    arrOut(r, c) = CDbl(arr1(r, c)) * CDbl(arr2(r, c))
                Else
                    arrOut(r, c) = CVErr(xlerrValue)
                End If
            Next c
        Next r

        ' Convert result array to XLOPER12
        Dim xMulti As XLOPER12
        xMulti = GetXLMulti12(arrOut)

        If xMulti.xltype <> xltypeMulti Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        ' Copy to static result and free allocated memory
        xResult = xMulti
        FreeXLMulti12 xMulti
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: GetXLMissing12 to pass an omitted optional argument to an Excel built-in
    ' Example: =TBXLL_TestMissing(3.7) -> 4
    [DllExport]
    Public Function TBXLL_TestMissing(ByRef pNum As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim args(1) As XLOPER12
        Dim xOut(0) As XLOPER12
        Dim xFree(0) As XLOPER12

        args(0) = pNum
        args(1) = GetXLMissing12()  ' omit digits, Excel defaults to 0

        If Excel12v(xlfRound, xOut(0), 2, args) <> 0 Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        xResult = GetXLNum12(Xloper12NumValue(xOut(0)))
        xFree(0) = xOut(0)
        Excel12v xlFree, ByVal vbNullPtr, 1, xFree
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: btArray input, per-element string construction, GetXLMulti12 string array return
    ' Example: =TBXLL_FormatArray({1,2;3,4}, "Item") -> {"Item_1","Item_2";"Item_3","Item_4"}  [Ctrl-Shift-Enter]
    [DllExport]
    Public Function TBXLL_FormatArray( _
        ByRef pRange As XLOPER12, _
        ByRef pPrefix As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim arrV() As Variant
        Dim prefix As String

        If Not Bind(pRange, btArray, arrV, xResult) Then Return VarPtr(xResult)
        If Not Bind(pPrefix, btString, prefix, xResult) Then Return VarPtr(xResult)

        Dim rows As Long = UBound(arrV, 1) + 1
        Dim cols As Long = UBound(arrV, 2) + 1
        Dim arrOut() As Variant
        ReDim arrOut(rows - 1, cols - 1)

        Dim r As Long, c As Long
        For r = 0 To rows - 1
            For c = 0 To cols - 1
                Select Case VarType(arrV(r, c))
                    Case vbDouble, vbLong
                        arrOut(r, c) = prefix & "_" & CStr(arrV(r, c))
                    Case vbString
                        arrOut(r, c) = prefix & "_" & arrV(r, c)
                    Case Else
                        arrOut(r, c) = CVErr(xlerrValue)
                End Select
            Next c
        Next r

        Dim xMulti As XLOPER12
        xMulti = GetXLMulti12(arrOut)

        If xMulti.xltype <> xltypeMulti Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If

        xResult = xMulti
        FreeXLMulti12 xMulti
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: btDate binding for Excel serial date input, direct double arithmetic on date values
    ' Example: =TBXLL_AddDays(A1, 30) -> serial date 30 days after A1
    [DllExport]
    Public Function TBXLL_AddDays( _
        ByRef pDate As XLOPER12, _
        ByRef pDays As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim dt As Double
        Dim days As Double

        If Not Bind(pDate, btDate, dt, xResult) Then Return VarPtr(xResult)
        If Not Bind(pDays, btNumber, days, xResult) Then Return VarPtr(xResult)

        ' Excel dates are stored as doubles - add days directly
        xResult = GetXLNum12(dt + days)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: btArray enumeration with VarType discrimination, skipping errors and empty cells
    ' Example: =TBXLL_SumArray2({1,2,3}) -> 6
    [DllExport]
    Public Function TBXLL_SumArray2(ByRef pRange As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim arrV() As Variant

        If Not Bind(pRange, btArray, arrV, xResult) Then Return VarPtr(xResult)

        Dim total As Double
        Dim r As Long, c As Long

        For r = 0 To UBound(arrV, 1)
            For c = 0 To UBound(arrV, 2)
                Select Case VarType(arrV(r, c))
                    Case vbDouble
                        total = total + arrV(r, c)
                    Case vbLong
                        total = total + CDbl(arrV(r, c))
                    Case vbError
                    Case vbEmpty
                    Case Else
                End Select
            Next c
        Next r

        xResult = GetXLNum12(total)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: btSingleCellRef validation, btValue extraction, GetXLVariant12 type-preserving return
    ' Example: =TBXLL_CellValue(A1) -> value of A1  |  =TBXLL_CellValue(A1:B2) -> error string
    ' Demonstrates: btSingleCellRef validation, btValue extraction, GetXLVariant12 type-preserving return
    ' Example: =TBXLL_CellValue(A1) -> value of A1  |  =TBXLL_CellValue(A1:B2) -> #VALUE!
    [DllExport]
    Public Function TBXLL_CellValue(ByRef pRef As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim v As Variant

        ' Validate is a single cell reference
        If Not Bind(pRef, btSingleCellRef, v, xResult) Then Return VarPtr(xResult)

        ' Extract the variant value
        If Not Bind(pRef, btValue, v, xResult) Then Return VarPtr(xResult)

        xResult = GetXLVariant12(v)
        Return VarPtr(xResult)
    End Function

    ' Demonstrates: Chaining Excel built-in output (xlfSum) into twinBASIC array processing and GetXLMulti12 array return
    ' Example: =TBXLL_NormalizeArray({4,9,16,25}) -> {0.0741,0.1667,0.2963,0.4630}  [Ctrl-Shift-Enter]
    [DllExport]
    Public Function TBXLL_NormalizeArray(ByRef pRange As XLOPER12) As LongPtr
        Static xResult As XLOPER12
        Dim arrV() As Variant

        If Not Bind(pRange, btArray, arrV, xResult) Then Return VarPtr(xResult)
        
        ' Get SUM of input via Excel built-in
        Dim args(0) As XLOPER12
        Dim xSum(0) As XLOPER12
        Dim xFree(0) As XLOPER12

        args(0) = pRange
        If Excel12v(xlfSum, xSum(0), 1, args) <> 0 Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If
  
        Dim total As Double = Xloper12NumValue(xSum(0))
        xFree(0) = xSum(0)
        Excel12v xlFree, ByVal vbNullPtr, 1, xFree

        If total = 0 Then
            xResult = GetXLErr12(xlerrDiv0)
            Return VarPtr(xResult)
        End If

        ' Build normalized variant array
        Dim rows As Long = UBound(arrV, 1) + 1
        Dim cols As Long = UBound(arrV, 2) + 1
        Dim arrOut() As Variant
        ReDim arrOut(rows - 1, cols - 1)

        Dim r As Long, c As Long
        For r = 0 To rows - 1
            For c = 0 To cols - 1
                Select Case VarType(arrV(r, c))
                    Case vbDouble, vbLong
                        arrOut(r, c) = CDbl(arrV(r, c)) / total
                    Case Else
                        arrOut(r, c) = CVErr(xlerrValue)
                End Select
            Next c
        Next r

        Dim xMulti As XLOPER12
        xMulti = GetXLMulti12(arrOut)

        If xMulti.xltype <> xltypeMulti Then
            SetErrorResult xResult
            Return VarPtr(xResult)
        End If
        
        xResult = xMulti
        FreeXLMulti12 xMulti
        Return VarPtr(xResult)
    End Function
    
    ' Demonstrates: Dynamic per-call heap allocation with xlbitDLLFree and xlAutoFree12 cleanup
    ' Example: =TBXLL_DynamicString("hello") -> "hello"
    [DllExport]
    Public Function TBXLL_DynamicString(ByRef pText As XLOPER12) As LongPtr
        ' Note: NO Static here - result is allocated dynamically per call
        Dim s As String
        Dim xTemp As XLOPER12
        If Not Bind(pText, btString, s, xTemp) Then GoTo ReturnResult
        xTemp = GetXLString12(s)
    ReturnResult:
        Return AllocXLOPER12Result(xTemp)
    End Function
    
    [DllExport]
    Public Function TBXLL_DynamicNumber() As LongPtr
        ' Note: NO Static here - result is allocated dynamically per call
        Dim pResult As LongPtr
        pResult = GlobalAlloc(GPTR, LenB(Of XLOPER12))
        If pResult = 0 Then Return 0

        Dim xResult As XLOPER12
        xResult = GetXLNum12(99)
        ' xlbitDLLFree tells Excel to call xlAutoFree12 when done with this result
        xResult.xltype = xResult.xltype Or xlbitDLLFree

        CopyMemory ByVal pResult, xResult, LenB(Of XLOPER12)
        Return pResult
    End Function
    
    [DllExport]
    Public Function TBXLL_DynamicBoolean() As LongPtr
        ' Note: NO Static here - result is allocated dynamically per call
        Dim pResult As LongPtr
        pResult = GlobalAlloc(GPTR, LenB(Of XLOPER12))
        If pResult = 0 Then Return 0

        Dim xResult As XLOPER12
        xResult = GetXLBool12(True)
        ' xlbitDLLFree tells Excel to call xlAutoFree12 when done with this result
        xResult.xltype = xResult.xltype Or xlbitDLLFree

        CopyMemory ByVal pResult, xResult, LenB(Of XLOPER12)
        Return pResult
    End Function
    
    /*
    ' Zero-arg UDF that returns current process memory usage
    [DllExport]
    Public Function TBXLL_ProcessMemory() As LongPtr
        Static xResult As XLOPER12
        Dim ms As MEMORYSTATUSEX
        ms.dwLength = LenB(ms)
        GlobalMemoryStatusEx ms
        xResult = GetXLNum12(CDbl(ms.ullTotalVirtual - ms.ullAvailVirtual))
        Return VarPtr(xResult)
    End Function
    */
End Module